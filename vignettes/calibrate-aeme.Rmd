---
title: "Calibrate AEME"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Calibrate AEME}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 80
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE
)
unlink("calib-test", recursive = TRUE, force = TRUE)
```

## Setup

First, we will load the `AEME` and `aemetools` package:

```{r setup, message = FALSE, warning=FALSE}
library(AEME)
library(aemetools)
```

Create a folder for running the example calibration setup.

```{r create-folder}

tmpdir <- "calib-test"
dir.create(tmpdir, showWarnings = FALSE)
aeme_dir <- system.file("extdata/lake/", package = "AEME")
# Copy files from package into tempdir
file.copy(aeme_dir, tmpdir, recursive = TRUE)
path <- file.path(tmpdir, "lake")

list.files(path, recursive = TRUE)
```

## Build AEME ensemble

Using the `AEME` functions, we will build the AEME model setup. For this
example, we will use the `glm_aed` model. The `build_ensemble` function will

```{r build-aeme-example, warning=FALSE, message=FALSE}

aeme_data <- yaml_to_aeme(path = path, "aeme.yaml")
mod_ctrls <- read.csv(file.path(path, "model_controls.csv"))
inf_factor = c("dy_cd" = 1, "glm_aed" = 1, "gotm_wet" = 1)
outf_factor = c("dy_cd" = 1, "glm_aed" = 1, "gotm_wet" = 1)
model <- c("glm_aed")
aeme_data <- build_ensemble(path = path, aeme_data = aeme_data,
                            model = model, mod_ctrls = mod_ctrls,
                            inf_factor = inf_factor, ext_elev = 5,
                            use_bgc = FALSE)

```

Run the model ensemble using the `run_aeme` function to make sure the current
model setup is working.

```{r}
#| label: run-aeme-example
#| fig.height: 8
#| fig.width: 8
#| cache: false
#| fig.cap: "Simple plots of surface and bottom water temperarure
#| an lake level after running AEME with the glm_aed model."

aeme_data <- run_aeme(aeme_data = aeme_data, model = model,
                      verbose = FALSE, mod_ctrls = mod_ctrls,
                      path = path)
plot(aeme_data)
```

## Load parameters to be used for the calibration

Parameters are loaded from the `aemetools` package within the `aeme_parameters`
dataframe. The parameters are stored in a data frame with the following columns:

-   `model`: The model name

-   `file`: The file name of the model parameter file

-   `name`: The parameter name

-   `value`: The parameter value

-   `min`: The minimum value of the parameter

-   `max`: The maximum value of the parameter

Parameters to be used for the calibration. (man)

```{r}
#| label: load-parameters
#| tbl-captions: "Parameters to be used for the calibration."
utils::data("aeme_parameters", package = "aemetools")
aeme_parameters

```

This dataframe can be modified to change the parameter values. For example, we
can change the `light/Kw` parameter for the `glm_aed` model to 0.1:

```{r change-parameters}
aeme_parameters[aeme_parameters$model == "glm_aed" &
                  aeme_parameters$name == "light/Kw", "value"] <- 0.1
aeme_parameters
```

This dataframe can be passed to the `run_aeme_param` function to run AEME with
the parameter values specified in the dataframe. This function is different to
the `run_aeme` function in that it does not return an `aeme_data` object, but
the model output is generate within the lake folder.

```{r run-aeme-param}
run_aeme_param(aeme_data = aeme_data, param = aeme_parameters,
                 model = model, path = path, mod_ctrls = mod_ctrls)

```

## Calibration setup

### Define fitness function

First, we will define a function for the calibration function to use to
calculate the fitness of the model. This function takes a dataframe as an 
argument. The dataframe contains the observed data (`obs`) and the modelled data
(`model`). The function should return a single value.

Here we use the root mean square error (RMSE) as the fitness function:

$$\text{RMSE}(y, \hat{y}) = \sqrt{\frac{\sum_{i=0}^{N - 1} (y_i - \hat{y}_i)^2}{N}}$$

```{r define-fitness-function}
# Function to calculate fitness
rmse <- function(df) {
  sqrt(mean((df$obs - df$model)^2))
}

```

Different functions can be applied to different variables. For example, we can
use the RMSE for the lake level and the mean absolute error (MAE) for the
water temperature:

```{r define-fitness-function-2}
# Function to calculate fitness
mae <- function(df) {
  mean(abs(df$obs - df$model))
}

```

Then these would be combined into a named list of functions which will be 
passed to the `calib_aeme` function. They are named according to the target
variable.

```{r define-function-list}

# Create list of functions
FUN_list <- list(HYD_temp = mae, LKE_lvlwtr = rmse)

```


### Define control parameters

Next, we will define the control parameters for the calibration. The control
parameters are generated using the `create_control` funtion and are then passed
to the `calib_aeme` function. The control parameters for calibration are as 
follows:

-   `VTR`: The value to reach. The calibration will stop when the fitness value
    is less than or equal to this value. For this example
-   `NP`: The number of individuals in the population. Best practice is to use
    10 times the number of parameters.
-   `itermax`: The maximum number of iterations to run the calibration for. The
    calibration will stop when this number of iterations is reached. The number
    of generations used is equal to `itermax / NP`. Therefore, through adjusting
    `NP` and `itermax` the number of generations can be adjusted.
-   `reltol`: The relative tolerance for the calibration. The calibration will
    stop when the relative change in the fitness value is less than this value.
-   `p`: The quantile used to select the parents for the next generation. For
    example, if `p = 0.25`, the best 25% of the population will be used as
    parents for the next generation.
-   `mutate`: The mutation rate for the calibration. This is the probability of
    a parameter being mutated.
-   `parallel`: Whether to run the calibration in parallel. This will decrease
    the time taken to run the calibration.
-   `out_file`: The file to write the calibration results to.
-   `na_value`: The value to use for missing values in the observed and
    predicted data. This is used to indicate when the model crashes and then can
    be easily removed from the calibration results.
-   `ncore`: The number of cores to use for the calibration. This is only used
    if `parallel = TRUE`.

Here is an example of the control parameters:

```{r define-control-parameters}
ctrl <- create_control(method = "calib", VTR = 1, NP = 40, itermax = 400, 
                       reltol = 0.07, cutoff = 0.25, mutate = 0.1, 
                       parallel = TRUE, out_file = "results.csv", 
                       na_value = 999, ncore = 2L)
```

### Define variables

Next we will select the variables to use for the calibration. The variables
selected need to use the AEME variable definition e.g.
`c("HYD_temp", "LKE_lvlwtr")`. Weights need to be attributed to each of the
variables. The weights are used to scale the fitness value. This can be helpful
if the variables have different units. For example, if the temperature is in
degrees Celsius and the water level is in metres, then the water level will have
a much larger impact on the fitness value. Therefore, the weight for the water
level should be much smaller than the weight for the temperature.

The weights are specified in a named vector. The names of the vector should be
the same as the variable names.

```{r define-variables}
vars_sim <- c("HYD_temp")
weights <- c("HYD_temp" = 1)
```

## Run calibration

Once we have defined the fitness function, control parameters and variables, we
can run the calibration. The `calib_aeme` function takes the following
arguments:

-   `aeme_data`: The `aeme_data` object to use for the calibration.
-   `path`: The path to the lake folder.
-   `param`: The parameters to calibrate.
-   `model`: The model to calibrate.
-   `mod_ctrls`: The model controls to use for the calibration.
-   `FUN_list`: The list of functions to use for each variable within the calibration.
-   `ctrl`: The control parameters to use for the calibration.
-   `vars_sim`: The variables to use for the calibration.
-   `weights`: The weights to use for the calibration.

The `calib_aeme` function writes the calibration results to the file specified
after each generation. This allows the calibration to be stopped and restarted
at any time. The `calib_aeme` function returns the `ctrl` object with any
updated values.

```{r run-calibration, cache=FALSE}
sim_id <- calib_aeme(aeme_data = aeme_data, path = path,
                   param = aeme_parameters, model = model,
                   mod_ctrls = mod_ctrls, FUN_list = FUN_list, ctrl = ctrl,
                   vars_sim = vars_sim, weights = weights)

```

## Visualise calibration results

The calibrations results can be read in using the `read_calib` function. This
function takes the following arguments:

-   `ctrl`: The control parameters used for the calibration.
-   `model`: The model used for the calibration.

The `read_calib` function returns a dataframe with the calibration results. The
calibration results include the model, generation, index (model run), parameter
name, parameter value, fitness value and the median fitness value for each
generation.

These results can be visualised using the `plot_calib` function. This function
takes the following arguments:

-   `calib`: The calibration results as read in using the `read_calib` function.
-   `model`: The model used for the calibration.
-   `ctrl`: The control parameters used for the calibration.

And returns a list of ggplot objects: a dotty plot, density plot and convergence
plot.

```{r visualise-calibration-results, cache = FALSE}

calib_res <- read_simulation_output(ctrl = ctrl, sim_id = sim_id)
plist <- plot_calib(calib = calib_res, na_value = ctrl$na_value)
```

### Dotty plot

This can be used for comparing sensitivity across parameters. The dotty plot
shows the fitness value for each parameter value for each generation. The
fitness value is on the y-axis and the parameter value is on the x-axis. It is
faceted by the parameter name. The parameter values are coloured by the
generation. The best fitness value for each generation is shown as a black line
with a red dot.

```{r dotty-plot, fig.width = 8, fig.height = 6}
plist$dotty
```

### Histogram plot

This is useful for comparing the distribution of parameter values across
generations. The histogram plot shows the frequency of the parameter values for
each generation. The parameter values are on the x-axis and the density is on
the y-axis. It is faceted by the parameter name.

If a parameter is converging on a value, then the histogram will show a peak
around that value. If a parameter is not converging on a value, then the
histogram will show a flat distribution.

```{r histogram-plot, fig.width = 8, fig.height = 6}
plist$hist
```

### Convergence plot

This is more generally used for assessing model convergence. The convergence
plot shows the values use over the iterations. The parameter value is on the
y-axis and the iteration is on the x-axis. It is faceted by the parameter name.
The parameter values are coloured by the generation. The best fitness value for
each generation is shown as a solid horizontal black line.

```{r convergence-plot, fig.width = 8, fig.height = 6}
plist$convergence
```
